#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <stack>
#include <stdlib.h>
#include <cstring>
#include <string.h>
#include <iomanip>
#include <algorithm>

using namespace std;

bool take_action(string name);

string iKT[36] = {"KT","char","main","double","enum","float","int","long","short","signed","struct",
                 "union","unsigned","void","for","do","while","break","continue","if",
                 "else","goto","switch","case","default","return","auto","extern","register",
                 "static","const","sizeof","typedef","volatile","cout","cin"};

string iPT[35] = {"PT","<=",">=","==","=","!=","+=","-=","*=","/=",">","<","+","-","*","/","++","--",
                 "{","}","(",")","[","]","->",".",",",";","&&","||","!","&","|","<<",">>"};

vector <string> KT(iKT,iKT+36);

vector <string> PT(iPT,iPT+35);

vector <string> IT(1,"IT");

vector <string> CT(1,"CT");

vector <string> ST(1,"ST");

vector <string> CCT(1,"CCT");

string LETTER = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

string SYMBOL = "!+-*/{}()[].,;_";

string NUMBER = "1234567890";

string w,w_before;

int hang;

vector <string> SEM;

typedef struct plotnode
{
    string name;
    int num;
    plotnode *next;
    plotnode *prior;
}plotnode;

class plotlist
{
    public:
        plotnode *head;
        plotnode *last;
        plotlist(){}
        int isin(string name);
        void clr();
        void inilist(string name,int num);
        void append(string name);
        void add(string name,int num);
};

class scan
{
    public:
        plotlist tL,tA,bKT,bPT;
        int state_change(int state,char ch);
        void state_token(int state_before,string token);
        int inIT(string str);
        int inCT(string str);
        int inST(string str);
        int inCCT(string str);
        int inPT(string str);
        int inKT(string str);
};

void plotlist::inilist(string name,int num)//初始化链表
{
    head = new plotnode;
    head->name = name;
    head->num = num;
    last = head;
    head->next = NULL;
    head->prior = NULL;
}

void plotlist::add(string name,int num)//表尾添加数据
{
    plotnode *p;
    p = last;
    last = new plotnode;
    last->name = name;
    last->prior = p;
    last->num = num;
    last->next = NULL;
    p->next = last;
}

void plotlist::clr()
{
    plotnode *p;
    p = this->head;
    for(int i=0;p!=NULL;p=p->next)
        delete p;
}

int plotlist::isin(string str)//返回字符串在表中位置
{
    int num = 0;
    plotnode *p;
    p = this->head;
    for(int i = 0;p!=NULL;p = p->next)
    {
        num = p->num;
        if(str == p->name)
            return num;
    }
    this->add(str,num+1);
    return num;
}

int scan::state_change(int state,char ch)
{
    switch(state)
    {
        case 1:
            if(LETTER.find(ch) != LETTER.npos) return 2;
            else if(ch == '_') return 2;
            else if(NUMBER.find(ch) != NUMBER.npos) return 3;
            else if(ch == '\'') return 9;
            else if(ch == '"') return 11;
            else if(ch == '>') return 4;
            else if(ch == '<') return 5;
            else if(ch == '=') return 6;
            else if(ch == '&') return 22;
            else if(ch == '|') return 23;
            else if(ch == ' '||ch == '\n'||ch == '\r') return 1;
            else return 18;break;
        case 2:
            if(LETTER.find(ch) != LETTER.npos||NUMBER.find(ch) != NUMBER.npos||ch == '_') return 2;
            else return 0;break;
        case 3:
            if(NUMBER.find(ch) != NUMBER.npos) return 3;
            else if(ch == '.') return 8;
            else if(ch == 'e') return 19;
            else return 0;break;
        case 4:
            if(ch == '='||ch == '>') return 13;
            else return 0;break;
        case 5:
            if(ch == '='||ch == '<') return 14;
            else return 0;break;
        case 6:
            if(ch == '=') return 15;
            else return 0;break;
        case 7:
            if(NUMBER.find(ch) != NUMBER.npos) return 7;
            else if(ch == 'e') return 19;
            else return 0;break;
        case 8:
            if(NUMBER.find(ch) != NUMBER.npos) return 7;
            else {cout << "错误行数（" << hang << "）：小数点后只能为数字或e！！" << endl;return 0;}break;
        case 9:
            if(LETTER.find(ch) != LETTER.npos) return 10;
            else {cout << "错误行数（" << hang << "）：‘后只能为字符！！" << endl;return 0;}break;
        case 10:
            if(ch == '\'') return 16;
            else {cout << "错误行数（" << hang << "）：‘没有对应的单引号" << endl;return 0;}break;
        case 11:
            if(LETTER.find(ch) != LETTER.npos) return 12;
            else {cout << "错误行数（" << hang << "）：“后只能为字符！！" << endl;return 0;}break;
        case 12:
            if(LETTER.find(ch) != LETTER.npos) return 12;
            else if(ch == '"') return 17;
            else {cout << "错误行数（" << hang << "）：“没有对应的双引号！！" << endl;return 0;}break;
        case 13:
            return 0;break;
        case 14:
            return 0;break;
        case 15:
            return 0;break;
        case 16:
            return 0;break;
        case 17:
            return 0;break;
        case 18:
            return 0;break;
        case 19:
            if(ch == '+'||ch == '-') return 20;
            else {cout << "错误行数（" << hang << "）：科学计数法e后只能+或-！！"  << endl;return 0;}break;
        case 20:
            if(NUMBER.find(ch) != NUMBER.npos) return 21;
            else {cout << "错误行数（" << hang << "）：科学计数法e+或e-后必须为数字！！" << endl;return 0;}break;
        case 21:
            if(NUMBER.find(ch) != NUMBER.npos) return 21;
            else return 0;break;
        case 22:if(ch == '&') return 24;
                else return 0;break;
        case 23:if(ch == '|') return 25;
                else return 0;break;
        case 24:
            return 0;break;
        case 25:
            return 0;break;
        default:{cout << "错误行数（" << hang << "）：不支持的字符" << endl;return 0;}
    }
}

int scan::inIT(string str)
{
    int flag = 0,i;
    for(i=0;i<IT.size();i++)
        if(str == IT[i]){flag = 1;break;}
    if(flag == 1)
        return i;
    else
    {
        IT.push_back(str);
        return i;
    }
}

int scan::inCT(string str)
{
    int flag = 0,i;
    for(i=0;i<CT.size();i++)
        if(str == CT[i]){flag = 1;break;}
    if(flag == 1)
        return i;
    else
    {
        CT.push_back(str);
        return i;
    }
}

int scan::inST(string str)
{
    int flag = 0,i;
    for(i=0;i<ST.size();i++)
        if(str == ST[i]){flag = 1;break;}
    if(flag == 1)
        return i;
    else
    {
        ST.push_back(str);
        return i;
    }
}

int scan::inCCT(string str)
{
    int flag = 0,i;
    for(i=0;i<CCT.size();i++)
        if(str == CCT[i]){flag = 1;break;}
    if(flag == 1)
        return i;
    else
    {
        CCT.push_back(str);
        return i;
    }
}

int scan::inKT(string str)
{
    int flag = 0,i;
    for(i=0;i<KT.size();i++)
        if(str == KT[i]){flag = 1;break;}
    if(flag == 1)
        {tL.add("KT",i);tA.add("KT",i);}
    else
    {
        tL.add("IT",inIT(str));tA.add("IT",inIT(str));
    }
}

int scan::inPT(string str)
{
    int flag = 0,i;
    for(i=0;i<PT.size();i++)
        if(str == PT[i]){flag = 1;break;}
    if(flag == 1)
        return i;
    else
    {
        PT.push_back(str);
        return i;
    }
}

void scan::state_token(int state_before,string token)//通过上一次状态判断是什么token
{
    int num;
    switch(state_before)
    {
        case 2:inKT(token);break;
        case 3:tL.add("CCT",inCCT(token));tA.add("CCT",inCCT(token));break;
        case 4:tL.add("PT",inPT(token));tA.add("PT",inPT(token));break;
        case 5:tL.add("PT",inPT(token));tA.add("PT",inPT(token));break;
        case 6:tL.add("PT",inPT(token));tA.add("PT",inPT(token));break;
        case 7:tL.add("CCT",inCCT(token));tA.add("CCT",inCCT(token));break;
        case 13:tL.add("PT",inPT(token));tA.add("PT",inPT(token));break;
        case 14:tL.add("PT",inPT(token));tA.add("PT",inPT(token));break;
        case 15:tL.add("PT",inPT(token));tA.add("PT",inPT(token));break;
        case 16:tL.add("CT",inCT(token));tA.add("CT",inCT(token));break;
        case 17:tL.add("ST",inST(token));tA.add("ST",inST(token));break;
        case 18:tL.add("PT",inPT(token));tA.add("PT",inPT(token));break;
        case 21:tL.add("CCT",inCCT(token));tA.add("CCT",inCCT(token));break;
        case 24:tL.add("PT",inPT(token));tA.add("PT",inPT(token));break;
        case 25:tL.add("PT",inPT(token));tA.add("PT",inPT(token));break;
        default:cout << "error!" << endl;
    }
}

typedef struct VN
{
	string symbol;
	vector<string> p;//该非终结符的产生式
	vector<string> first;//该非终结符的FIRST集
	vector<string> follow;//该非终结符的FOLLOW集
}N;//非终结符
typedef  struct VT
{
	string vt;
}T;//终结符, num 用 n 代替

vector<N> vn;//定义非终结符集合
vector<T> vt;//定义终结符集合
vector<N> vn1;//带有语义动作
vector< vector<string> > tab;//分析表

void getN(vector<N> *n)//获取非终结符
{
    string c[]={"A","F","G","E","I","J","H","M","N","O","P","U","V","Q","W","R","S","T","B","L","C","Y","D","Z","F1","NU","NUU","Z1","FF","G1","G2","V2","V1"};
    for(int i=0;i<33;i++)
    {
       N temp;
       temp.symbol=c[i];
       n->push_back(temp);
    }


}
void getT(vector<T> *t)//获取终结符
{
    string c[]={"int","main","double","char","void","&&","||","!","+","-","*","/","(",")","[","]","{","}","'","=","<",">",">>","<<","==","<=",">=","s","id","num","ch","if","else","while","return","cout","cin",";",","};
    for(int i=0;i<39;i++)
    {
        T temp;
        temp.vt=c[i];
        t->push_back(temp);
    }
}
void getpRules(vector<N> *n)//获取产生式
{
    int k = 0;
    string rule[]={"A%F?Z?main?(?)?{?H?}?Z1?#",
                   "Z%id?(?G1?)?{?H?}?F?Z?#",
                   "Z%$?#",
                   "Z1%F?id?(?G1?)?{?H?}?Z1?#",
                   "Z1%$?#",
                   "F%int?#",
                   "F%double?#",
                   "F%char?#",
                   "F%void?#",
                   "G%I?E?#",
                   "G%$?#",
                   "G1%F1?id?G2?#",
                   "G2%,?G1?#",
                   "G2%$?#",
                   "E%,?I?E?#",
                   "E%$?#",
                   "I%F1?id?NUU?J?#",
                   "I%id?NUU?J?#",
                   "F1%int?#",
                   "F1%double?#",
                   "F1%char?#",
                   "NU%[?num?]?#",
                   "NU%$?#",
                   "J%=?B?#",
                   "J%$?#",
                   "H%M?N?#",
                   "M%G?;?M?#",
                   "M%$?#",
                   "N%O?N?#",
                   "N%P?N?#",
                   "N%Q?N?#",
                   "N%R?N?#",
                   "N%S?N?#",
                   "N%T?N?#",
                   "N%$?#",
                   "O%id?NUU?=?B?;?#",
                   "P%while?(?U?)?{?H?}?#",
                   "U%V2?V1?#",
                   "U%B?V?#",
                   "V1%&&?V2?V1?#",
                   "V1%||?V2?V1?#",
                   "V1%$?#",
                   "V2%(?B?V?)?#",
                   "V2%!?(?B?V?)?#",
                   "V%<?B?#",
                   "V%>?B?#",
                   "V%==?B?#",
                   "V%<=?B?#",
                   "V%>=?B?#",
                   "V%$?#",
                   "Q%if?(?U?)?{?H?}?W?#",
                   "W%else?{?H?}?#",
                   "W%$?#",
                   "R%return?B?;?#",
                   "S%cout?<<?B?;?#",
                   "T%cin?>>?id?;?#",
                   "B%C?L?#",
                   "B%ch?#",
                   "B%s?#",
                   "L%+?C?L?#",
                   "L%-?C?L?#",
                   "L%$?#",
                   "C%D?Y?#",
                   "Y%*?D?Y?#",
                   "Y%/?D?Y?#",
                   "Y%$?#",
                   "D%id?NUU?#",
                   "D%(?B?)?#",
                   "D%num?#",
                   "NUU%[?num?]?#",
                   "NUU%(?B?FF?)?#",
                   "NUU%$?#",
                   "FF%,?B?FF?#",
                   "FF%$?#"};
    for(int i=0;i<74;i++)
    {
        for(int j=0;j<(n->size());j++)
        {
            while(1)
                if(rule[i][k++]=='%')
                    break;
            string s(rule[i],0,k-1);
            k = 0;
            if(s==n->at(j).symbol)
            {
                n->at(j).p.push_back(rule[i]);
            }
        }
    }
}

void getpRules1(vector<N> *n)//获取产生式
{
    int k = 0;
    string rule[]={"A%F?Z?main?do(fun)?(?)?{?H?}?Z1?#",
                   "Z%id?do(fun)?(?G1?do(def)?)?{?H?}?F?Z?#",
                   "Z%$?#",
                   "Z1%F?id?do(fun)?(?G1?do(def)?)?{?H?}?Z1?#",
                   "Z1%$?#",
                   "F%int?#",
                   "F%double?#",
                   "F%char?#",
                   "F%void?#",
                   "G%I?E?#",
                   "G%$?#",
                   "G1%F1?id?do(var)?G2?#",
                   "G2%,?G1?#",
                   "G2%$?#",
                   "E%,?I?E?#",
                   "E%$?#",
                   "I%F1?id?do(push)?NUU?J?#",
                   "I%id?do(push)?NUU?J?#",
                   "F1%int?#",
                   "F1%double?#",
                   "F1%char?#",
                   "NU%[?num?do(push)?]?#",
                   "NU%$?#",
                   "J%=?B?do(=)?#",
                   "J%$?#",
                   "H%M?N?#",
                   "M%G?;?M?#",
                   "M%$?#",
                   "N%O?N?#",
                   "N%P?N?#",
                   "N%Q?N?#",
                   "N%R?N?#",
                   "N%S?N?#",
                   "N%T?N?#",
                   "N%$?#",
                   "O%id?do(push)?NUU?=?B?do(=)?;?#",
                   "P%while?do(while)?(?U?)?do(do)?{?H?}?do(we)?#",
                   "U%V2?V1?#",
                   "U%B?V?#",
                   "V1%&&?V2?do(&&)?V1?#",
                   "V1%||?V2?do(||)?V1?#",
                   "V1%$?#",
                   "V2%(?B?V?)?#",
                   "V2%!?(?B?V?)?do(!)?#",
                   "V%<?B?do(<)?#",
                   "V%>?B?do(>)?#",
                   "V%==?B?do(==)?#",
                   "V%<=?B?do(<=)?#",
                   "V%>=?B?do(>=)?#",
                   "V%$?#",
                   "Q%if?(?U?)?do(if)?{?H?}?W?do(ie)?#",
                   "W%else?do(el)?{?H?}?#",
                   "W%$?#",
                   "R%return?B?do(ret)?;?#",
                   "S%cout?<<?B?do(cout)?;?#",
                   "T%cin?>>?id?;?do(cin)?#",
                   "B%C?L?#",
                   "B%ch?do(push)?#",
                   "B%s?do(push)?#",
                   "L%+?C?do(+)?L?#",
                   "L%-?C?do(-)?L?#",
                   "L%$?#",
                   "C%D?Y?#",
                   "Y%*?D?do(*)?Y?#",
                   "Y%/?D?do(/)?Y?#",
                   "Y%$?#",
                   "D%id?do(push)?NUU?#",
                   "D%(?B?)?#",
                   "D%num?do(push)?#",
                   "NUU%[?num?do(arr)?]?#",
                   "NUU%do(fun2)?(?B?do(in)?FF?do(fe)?)?do(over)?#",
                   "NUU%$?#",
                   "FF%,?B?do(in)?FF?#",
                   "FF%$?#"};
    for(int i=0;i<74;i++)
    {
        for(int j=0;j<(n->size());j++)
        {
            while(1)
                if(rule[i][k++]=='%')
                    break;
            string s(rule[i],0,k-1);
            k = 0;
            if(s==n->at(j).symbol)
            {
                n->at(j).p.push_back(rule[i]);
            }
        }
    }
}

bool isVN(string s , vector<N> n)//判断字符是否为非终结符
{
	int judge = 0 , count = 0;
	if (n.size() > 0)
	{
		for (int i = 0; i < n.size(); i++)
		{
			count = i;
			if (s == n.at(i).symbol)
			{
				judge = 1;
				return true;
			}
		}
		if ((count == (n.size() - 1)) && (judge == 0))
		{
			return false;
		}
	}
	else
		return false;
}
bool isVT(string s , vector<T> t)//判断符号(除了num)是否为终结符,
{
	int judge = 0, count = 0;
	if (t.size() > 0 )
	{
		for (size_t i = 0; i < t.size(); i++)
		{
			count = i;
			if (s==t.at(i).vt)
			{
				judge = 1;
				return true;
			}
		}
		if (count == (t.size() - 1) && (judge == 0))
		{
			return false;
		}
	}
	else
		return false;
}
bool isEmptyIn(N n)//判断非终结符FIRST集是否含有空元素，有空元素(true);没空元素(false)
{
	int jugde = 0, i = 0;
	for (i = 0; i < n.first.size(); i++)
	{
		if (n.first.at(i) == "$")
		{
			jugde = 1;
			return true;
		}
	}
	if ((i == (n.first.size()) - 1) && (jugde == 0))
	{
		return false;
	}
}
int getVnPos(string s, vector<N> n)
/*获取某个非终结符在非终结符集合中的位置,
 若当前符号不在非终结符集合返回-1*/
{
	if (isVN(s, n) == true)//判断当前符号是否在非终结符集合
	{
		for (size_t i = 0; i < n.size(); i++)
		{
			if (s == n.at(i).symbol)
			{
				return i;
			}
		}
	}
	else
		return -1;
}

int getVtPos(string c, vector<T> t)
//获取某个终结符在终结符集合中的位置
{
	if (isVT(c , t) == true)//判断当前符号是否在终结符集合
	{
		for (int i = 0; i < t.size(); i++)
		{
			if (c == t.at(i).vt)
			{
				return i;
			}
		}
	}
	else
		return -1;
}
bool isExist(string c, N n, int i)
/*判断新求得的元素 是否和之前FIRST(1)/FOLLOW(2)集重复
	若重复返回true，不重复返回false
*/
{
	switch (i)
	{
	case 1://验证FIRST集
		if (n.first.size() == 0)
		{
			return false;
		}
		else
		{
			int judge = 0, count = 0;
			for (int i = 0; i < n.first.size(); i++)
			{
				count = i;
				if (n.first.at(i) == c)
				{
					judge = 1;
					return true;
				}
			}
			if ((judge == 0) && (count == (n.first.size() - 1)))
			{
				return false;
			}
		}
		break;
	case 2://验证FOLLOW集
		if (n.follow.size() == 0)
		{
			return false;
		}
		else
		{
			int judge = 0, count = 0;
			for (int i = 0; i < n.follow.size(); i++)
			{
				count = i;
				if (n.follow.at(i) == c)
				{
					judge = 1;
					return true;
				}
			}
			if ((judge == 0) && (count == (n.follow.size() - 1)))
			{
				return false;
			}
		}
		break;
	}
}
string getrulefirst(string t)//求产生式推出第一个字符
{
    int i=0;
    int j=0;
    while(1)
    {
        if(t.at(j)=='%')
            i = j;
        if(t.at(j)=='?')
            break;
        j++;

    }
    string s(t,i+1,j-i-1);
    return s;
}

int getSizerule(string s)//求产生式%后有几个字符
{
    int count=0,i=0;
    while(s.at(i)!='#')
    {
        if(s.at(i)=='?')
            count++;
        i++;
    }
    return count;
}
string getV(int n,string s)
{
    int k = 0;
    while(1)
        if(s[k++]=='%')
            break;
    if(n==0)
    {
        string x(s,0,k-1);
        return x;
    }
    if(n==1)
        return getrulefirst(s);
    else{
     int count1=0,count2=0;
    int i=0,j=0;
    while(s.at(i)!='#')
    {
        if(s.at(i)=='?')
            count1++;
        if(count1==n-1)
            break;
        i++;
    }

    while(s.at(j)!='#')
    {
        if(s.at(j)=='?')
            count2++;
        if(count2==n)
            break;
        j++;
    }
    string a(s,i+1,j-i-1);
    return a;
    }
}
void getFirst(vector<N> *n)//求每个非终结符的FIRST集
{
	int new_ = 0;//为1时重复求FIRST集，为0时结束循环
	unsigned int loc_vn = 0, loc_p = 0;//for循环中的计数器
	int count = 0;
	do//求FIRST集
	{
		for (loc_vn= 0; loc_vn < n->size(); loc_vn++)
			//对于位置在loc_vn的非终结符，根据其产生式求FIRST集
		{//cout << ":: " << n->at(loc_vn).symbol << endl;
			vector<string> temp = n->at(loc_vn).p;//该非终结符的产生式集合
			if ((temp.size()) > 0)
				//产生式的数目大于0
			{
				//分析每个产生式的情况
				for (loc_p = 0; loc_p < (temp.size()); loc_p++)
					//分析第i个产生式
				{//cout << "p:: " << temp[loc_p] << endl;
					string c_loc3 =getrulefirst(temp.at(loc_p)) ;//中间变量，每个产生式位置3处的字符
					if (isVN(c_loc3, vn) == true)
						//该非终结符的第i个产生式推出的第一个符号，例如E->E+F中的E  是非终结符
					{
						int n_loc3 = getVnPos(c_loc3, vn);
					//	cout << "xxxx " << n_loc3 << endl;
						if (n->at(n_loc3).first.size() == 0)
						{
							count++;
						//	cout << "n_loc3 " << n_loc3 << endl;
						}
						else
						{
							vector<string> n3_first = n->at(n_loc3).first;//中间变量，产生式中非终结符的FIRST集
							for (int i = 0; i < n3_first.size(); i++)
							{
								if (isExist(n3_first.at(i), n->at(loc_vn), 1) == false)
								{
									n->at(loc_vn).first.push_back(n3_first.at(i));
								}
							}
						}
					}
					if (isVT(c_loc3, vt) == true || (c_loc3 == "$"))
						//该非终结符的第i个产生式推出的第一个符 号，例如E->*F中的*     是终结符
					{
						if (isExist(c_loc3, n->at(loc_vn) , 1) == false)
						{
							n->at(loc_vn).first.push_back(c_loc3);
						//	if(n->at(loc_vn).symbol == "NUU") cout << "F1 <- " << c_loc3 << endl;
						}
					}
				}
			}
		}
		//确定是否循环求FIRST集
		if (count > 0)
		{
			new_ = 1;
		}
		else
		{
			new_ = 0;
		}
		count = 0;
	} while (new_ == 1);//循环求每个非终结符的FIRST集，直到每个集合不再添加新的元素结束循环
}
void getFollow(vector<N> *n)//获取非终结符的FOLLOW集
{
	int count = 40,flag = 0;
	unsigned int loc_vn = 0, loc_p = 0, loc_c = 0;//for循环中的计数器
	do
	{
		//按非终结符的顺序 遍历所有的产生式
		for (loc_vn = 0; loc_vn < n->size(); loc_vn++)
			//对于位置在loc_vn的非终结符，根据其产生式求FIRST集
		{
			if (isExist("#", n->at(0) , 2) == false)
			{
				n->at(0).follow.push_back("#");//起始符的FOLLOW集加入'#'符号
			}
			vector<string> temp = n->at(loc_vn).p;//该非终结符的产生式 集合
			if ((temp.size()) > 0)
			//产生式的数目大于0
			{
				//分析每个产生式的情况
				for (loc_p = 0; loc_p < (temp.size()); loc_p++)
				//分析第loc_p个产生式
				{
					for (loc_c = 1; loc_c <=getSizerule(temp.at(loc_p)); loc_c++)
					//分析该产生式的第loc_c个字符,从loc_c = 3的位置开始,对出现的所有非终结符求FOLLOW集
					{
						string tempc = getV(loc_c,temp.at(loc_p));//临时变量，保存当前要分析的 字符
						if ((isVN(tempc , vn) == true))//该字符为 非终结符，求该字符的FOLLOW集
					    //该字符为 非终结符 且后续至少有一个字符，读取下一个字符，判断是否为空
						{
							int pos_tempc = getVnPos(tempc, vn);//求该字符的FOLLOW集
							unsigned int loc_tempc;//FOLLOW集中的字符
							for (loc_tempc = loc_c; loc_tempc <=getSizerule(temp.at(loc_p)); loc_tempc++)
							{
								flag = 0;
								if (loc_tempc == getSizerule(temp.at(loc_p)))//产生式的最后一个符号是非终结符
								{
									int pos1 = getVnPos(getV(0,temp.at(loc_p)), vn);//
									if ((n->at(pos1).follow.size() == 0))
									{
										//count++;
									}
									else
									{
										vector<string> pos1_follow = n->at(pos1).follow;//产生式中非终结符(第一个字符)的FOLLOW集
										for (size_t i = 0; i < pos1_follow.size(); i++)
										{
											if (isExist(pos1_follow.at(i), n->at(pos_tempc), 2) == false)
												//FOLLOW集没有该元素
											{
												n->at(pos_tempc).follow.push_back(pos1_follow.at(i));
											}
										}
									}
								}
								else
								//当前分析的字符不是产生式的倒数第一个字符
								{
									string c = getV(loc_tempc + 1,temp.at(loc_p));
									if (c == "$"||c == "#")
										//非终结符后的第一个字符为空
										continue;
									else
										//非终结符后的第一个字符不为空
									{
										if (isVT(c , vt) == true)
											//是非空的终结符
										{
											if (isExist(c, n->at(pos_tempc), 2) == false)
											{
												n->at(pos_tempc).follow.push_back(c);
											}
											break;
										}
										if (isVN(c , vn) == true)
											//是非终结符
										{
											//遍历该非终结符的FIRST集
											int i = getVnPos(c, vn);
											for (size_t j = 0; j < n->at(i).first.size(); j++)
											{
												if (n->at(i).first.at(j) == "$")
													//FIRST集含中的空的元素
												{
													flag = 1;
												}
												else
													//非空元素
												{
													if (isExist(n->at(i).first.at(j), n->at(pos_tempc), 2) == false)
													{
														n->at(pos_tempc).follow.push_back(n->at(i).first.at(j));
													}
							 					}
											}
										}
									}
								}
								if(!flag) break;
							}
						}
					}
				}
			}
		}
		count --;
	} while (count > 0);
}

void analysisTab()//建立带有同步信息的预测分析表
{
	//初始化分析表的行数、列数
	tab.resize(vn.size());//行数,非终结符的个数
	for (size_t i = 0; i < vn.size(); i++)
	{
		tab[i].resize((vt.size() + 1));
	}//列数，终结符的个数+1(#)
	for (size_t i = 0; i < vn.size(); i++)//遍历每个非终结符
	{
		vector<string> tempFollow = vn[i].follow;//推导出该产生式的非终结符的FOLLOW集
		for (size_t j = 0; j < vn[i].p.size(); j++)//每个非终结符开头的产生式
		{
			string tempc = getV(1,vn[i].p[j]);
			if (isVT(tempc , vt) == true)
			//终结符
			{
				int posT = getVtPos(tempc , vt);//终结符
				tab[i][posT] = vn1[i].p[j];
            //    if(vn[i].symbol=="NUU") cout << vn1[i].p[j] << " qqqq" << tempc << " ffff" << vn.at(i).symbol << " " << vt.at(posT).vt << endl;

			}
			if (tempc == "$")
			{
				for (size_t k = 0; k < tempFollow.size(); k++)
				{
					//vn[i].follow
					if (tempFollow.at(k) != "#")
					{
						int posFollow = getVtPos(tempFollow.at(k), vt);
						if(tab[i][posFollow].empty()) tab[i][posFollow] = vn1[i].p[j];
                     //   if(vn[i].symbol=="NUU") cout << vn[i].p[j] << " zzzz" << tempc << " ffff" << vn.at(i).symbol << " " << vt.at(posFollow).vt << endl;

					}
					else
						//FOLLOW集中有#
					{
						tab[i][vt.size()] = vn1[i].p[j];
					}
				}
			}

			if (isVN(tempc, vn) == true)
			//非终结符
			{
				int posN = getVnPos(tempc , vn);//非终结符
				vector<string> tempFirst = vn.at(posN).first;
				for (size_t f = 0; f < tempFirst.size(); f++)
				{
					if (tempFirst.at(f) != "$")
					{
						int posFirst = getVtPos(tempFirst.at(f), vt);//获取该元素的位置
						tab[i][posFirst] = vn1[i].p[j];
						//if(vn[i].symbol=="NUU") cout << vn[i].p[j] << " ffff" << tempc << " ffff" << vn.at(i).symbol << " " << vt.at(posFirst).vt << endl;
					}
				}
				if (isEmptyIn(vn.at(posN)) == true)
				//非终结符的FIRST集含空元素
				{
					if (getSizerule(vn[i].p[j])>1)
					{
						int judge = 0;//产生式若能退出空，为0

						//分析产生式的后续字符
						unsigned l;
						for (l = 2; l <=getSizerule(vn[i].p[j]); l++)
						{
							if (isVT(getV(l,vn[i].p[j]), vt) == true)
							//空 后面跟了非空终结符,只处理这一个字符即可
							{
								int posT = getVtPos(getV(l,vn[i].p[j]), vt);
								tab[i][posT] = vn1[i].p[j];
                            //    if(vn[i].symbol=="NUU") cout << vn[i].p[j] << " ffff" << tempc << " dddd" << vn.at(i).symbol << " " << vt.at(posT).vt << endl;

								judge = 1;
								break;
							}
							if (isVN(getV(l,vn[i].p[j]), vn) == true)
							//空 后面跟了非终结符
							{
								int m = getVnPos(getV(l,vn[i].p[j]), vn);	//获取该非终结符位置
								for (size_t f = 0; f < vn[m].first.size(); f++)
								{
									if (vn[m].first.at(f) != "$")
									{
										int posFirst = getVtPos(vn[m].first.at(f), vt);//获取该元素在FIRST集的位置
										tab[i][posFirst] = vn1[i].p[j];
                                 //       if(vn[i].symbol=="NUU") cout << vn[i].p[j] << " dddd" << tempc << " ffff" << vn.at(i).symbol << " " << vt.at(posFirst).vt << endl;

									}
								}
								if (isEmptyIn(vn[m]) == true)//非终结符的FIRST集含空元素
								{
									continue;
								}
								else
								{
									judge = 1;
									break;
								}
							}
						}
						if ((l == getSizerule(vn[i].p[j])) && (judge == 0))//产生式能退出空
						{
							//vn[i].follow
							for (size_t k = 0; k < tempFollow.size(); k++)
							{
								if (tempFollow.at(k) != "#")
								{
									int posFollow = getVtPos(tempFollow.at(k), vt);
									tab[i][posFollow] = vn1[i].p[j];
              //                      if(vn[i].symbol=="NUU") cout << vn[i].p[j] << " dddd" << tempc << " dddd" << vn.at(i).symbol << " " << vt.at(posFollow).vt << endl;

								}
								else
								//FOLLOW集中有#
								{
									tab[i][vt.size()] = vn1[i].p[j];
								}
							}
						}
					}
					else
					//该产生式的非终结符可以推出空元素,看FOLLOW集
					{
						for (size_t k = 0; k < tempFollow.size(); k++)
						{
							//vn[i].follow
							if (tempFollow.at(k) != "#")
							{
								int posFollow = getVtPos(tempFollow.at(k), vt);
								tab[i][posFollow] = vn1[i].p[j];
                         //       if(vn[i].symbol=="W") cout << vn[i].p[j] << " dddd" << tempc << " wwww" << vn.at(i).symbol << " " << vt.at(posFollow).vt << endl;

							}
							else
							//FOLLOW集中有#
							{
								tab[i][vt.size()] = vn1[i].p[j];
							}
						}
					}
				}
			}
		}
	}

}

bool doyuyi(string x)
{
    int flag = 1;
    if(x=="do(push)") flag = 0;
    if(x=="do(+)") flag =0;
    if(x=="do(-)") flag =0;
    if(x=="do(*)") flag =0;
    if(x=="do(/)") flag =0;
    if(x=="do(=)") flag =0;
    if(x=="do(<)") flag =0;
    if(x=="do(>)") flag =0;
    if(x=="do(==)") flag =0;
    if(x=="do(<=)") flag =0;
    if(x=="do(>=)") flag =0;
    if(x=="do(!)") flag =0;
    if(x=="do(&&)") flag =0;
    if(x=="do(||)") flag =0;
    if(x=="do(while)") flag =0;
    if(x=="do(if)") flag =0;
    if(x=="do(el)") flag =0;
    if(x=="do(ie)") flag =0;
    if(x=="do(we)") flag =0;
    if(x=="do(cin)") flag =0;
    if(x=="do(cout)") flag =0;
    if(x=="do(do)") flag =0;
    if(x=="do(fun)") flag =0;
    if(x=="do(arr)") flag =0;
    if(x=="do(ret)") flag =0;
    if(x=="do(var)") flag =0;
    if(x=="do(def)") flag =0;
    if(x=="do(fun2)") flag =0;
    if(x=="do(in)") flag =0;
    if(x=="do(fe)") flag =0;
    if(x=="do(over)") flag =0;
    return flag;
}

string re(plotnode *p)
{
    if(p->name == "IT")
        return IT[p->num];
    else if(p->name == "CT")
        return CT[p->num];
    else if(p->name == "CCT")
        return CCT[p->num];
    else if(p->name == "ST")
        return ST[p->num];
    else if(p->name == "KT")
        return KT[p->num];
    else return PT[p->num];
}

string rre(plotnode *p)
{
    if(p->name == "IT")
        return "id";
    else if(p->name == "CT")
        return "ch";
    else if(p->name == "CCT")
        return "num";
    else if(p->name == "ST")
        return "s";
    else if(p->name == "KT")
        return KT[p->num];
    else return PT[p->num];
}

bool xxw(string x,string ww)
{
    int flag = 1;
    if(x == "id")
        if (std::find(IT.begin(), IT.end(), ww) != IT.end())
            flag = 0;
    if(x == "num")
        if (std::find(CCT.begin(), CCT.end(), ww) != CCT.end())
            flag = 0;
    if(x == "ch")
        if (std::find(CT.begin(), CT.end(), ww) != CT.end())
            flag = 0;
    if(x == "s")
        if (std::find(ST.begin(), ST.end(), ww) != ST.end())
            flag = 0;
    if(x == ww)
        flag = 0;
    return flag;
}

bool yufa(plotnode *p)
{
    string xx,str;
    plotnode *p1;
    int vtpos;
    vector <string> syn(1,"#");
    syn.push_back("A");
    xx = syn.back();
    syn.pop_back();
    string c;
    w = re(p);
    for(int i=0;;i++)
    {
        cout << std::left << setw(3) << "x: " << std::left << setw(10) << xx << std::left << setw(3) << "w: " << std::left << setw(8) << w << " ";
        if(doyuyi(xx))
        if(xxw(xx,w))
            if(isVN(xx,vn))
            {
                if(w == "#") vtpos = 39;
                else vtpos = getVtPos(rre(p),vt);
                str = tab[getVnPos(xx,vn)][vtpos];
               // if(xx == "M") cout << "M : " << str << "  " << getVnPos(xx,vn) << " " << vtpos << " " << rre(p) << endl;
                for(int j=str.size()-1;;j--)
                {
    //                if(j==str.size()-1) cout << "666 ";
                    if(str[j] != '?'&&str[j] != '#'&&str[j] != '%'&&str[j] != '$')
                    {
                        c = str[j] + c;
                        if(j==0) break;
                    }
                    else if(str[j] == '?'&&c.size()>0)
                    {
                    //    cout << " " << c;
                        syn.push_back(c);
                        c.clear();
                    }
                    else if(str[j] == '%'&&c.size()>0)
                    {
                    //    cout << " " << c;
                        syn.push_back(c);
                        c.clear();
                        break;
                    }
                    else if(str[j] == '$')
                        break;
                }
            }
            else return false;
        else p=p->next;
        cout << "syn: ";
        for(int j=0;j<syn.size();j++)
            cout << syn[j] << " ";
        p1=p;
        cout << "last: ";
        for(int l=0;p1!=NULL;p1=p1->next)
            cout << re(p1) << " ";
        cout << endl;
        take_action(syn.back());
   //     cout << "sem: ";
   //     if(SEM.size()>0) cout << SEM.back() << endl;
        xx = syn.back();
        syn.pop_back();
        if(p != NULL)
            w = re(p);
        else w = "#";
        if(xx == "#"&&w == "#")
        {
            cout << std::left << setw(3) << "x: "<< std::left << setw(3) << xx << "w: " << std::left << setw(8) << w << " ";
            cout << "syn: ";
            for(int j=0;j<syn.size();j++)
                cout << syn[j] << " ";
            cout << "last: ";
            for(int l=0;p1!=NULL;p1=p1->next)
                cout << re(p1) << " ";
            cout << endl;
            return true;
        }

    }
}

typedef struct AINFL_node     //数组表
{
     int low,high,lenth;
     AINFL_node *next;
     struct TVAL_node * tap;
}AINFL_node;
typedef struct            //数组表结点
{
    AINFL_node *head;
    AINFL_node *top;
}AINFL;
typedef struct TVAL_node
{
     string tp;     //填表就等于你接受到的关键字
     AINFL_node *aip;   //指向数组表
     TVAL_node *next;
}TVAL_node;
typedef struct TVAL           //类型表定义
{
    TVAL_node *top;
    TVAL_node *head;
}TVAL;


typedef struct FPMnode
{
    string name;    //形参名字
    TVAL_node *tva; //指向类型表
    string var_cat;//形参类型  vf.fn
    int vall_add;  //指向活动记录中的address
    FPMnode *next;  //next指针
}FPMnode;   //formal parameter table 形参表结点

typedef struct
{
    FPMnode *head;
    FPMnode *top;
}FPMtable;      //形参表

typedef struct PFnode
{
    int level,off;      //层次和区距
    int num;        //形参个数
    int entry;   //入口地址初步按0算
    FPMnode *fpm; //形参表
    PFnode *next;
}PFnode;    //函数表结点

typedef struct
{
    PFnode *head;
    PFnode *top;
}PFINFL;    //函数表


//符号表数据结构
typedef struct symbol_node
{
    string name;
    TVAL_node *typ;         //指向类型表或者
    string cat;          //指向类型编号      //数组指向长度表，函数指向函数表
    symbol_node *next;       //next
    PFnode *pf;              //函数标识符指向函数表
    //int *ltp;                //数组或结构体指向长度
    int vall_add;       //函数形参或者变量指向vall表
}symbol_node;
typedef struct
{
    symbol_node *head;     //队头指针
    symbol_node *top;    //队尾指针
}symbol_table;


//以下开始测试
class vallnode
{
public:
    string name;//如果无意义"#"
    int add;//如果无意义-1
    vallnode(){name = "#";add = -1;}
    ~vallnode(){}
};

class valltable
{
public:
    vector <vallnode> table;
    int level;
    valltable(int level);
    void fill_all_table(plotnode *&p,symbol_node *symn);        //将函数形参表及符号总表及活动记录填完
    valltable(){}
    ~valltable(){}
};
valltable::valltable(int level)
{
    this->level = level;
    table.resize(3);
    table[0].add = 0; //oldsp
    table[1].add = 0; //全局display
    table[2].add = 0; //将形参个数初始为0
}
class search_node  //符号表函数索引表结点
{
public:
    string name;
    symbol_node *symn;
    valltable *vallt;
    search_node(){}
    ~search_node(){}
    void copy_node(string name,symbol_node *symn,valltable *vallt)
    {
        this->name = name;
        this->symn = symn;
        this->vallt = vallt;
    }
};




void fill_fpmt(string name,string type,string var_cat,int vall_add);
void fill_symt_copy_fpm(FPMnode *fpm);
int getbyte(symbol_node *symn);
void fill_searcht(string name,symbol_node *symn,valltable *vallt);
int find_searcht(string s);
void change_level_cnt(plotnode *p);
int get_vall_add_and_fill(symbol_node *symn);
void fill_symbol_all(plotlist &ll);
void fill_AINFL(string s,plotnode *&p);
void printvall(vallnode v);
void printvall_all();
void initPFINFL();
void initFPMtable();

vector <valltable> vall_all;//活动记录总表    main函数中resize 0
FPMtable fpmt;//函数形参表
TVAL tvalt;//类型表
AINFL ainflt;
PFINFL pft;//函数表
symbol_table symt;//符号表
vector <search_node> searcht;   //索引表
valltable *current_vallt;   //指向当前函数的活动记录指针
int level_cnt = -1;  //计算大括号深度
bool isinfun = false;//表示当前是否在函数内部   当isinfun = false,则表示全局变量

void initsymt()
{
    symbol_node *p =new symbol_node;
    p->next = NULL;
    symt.head = symt.top = p;
    p = NULL;
    delete p;
}

void initTVAL()
{
    TVAL_node *t = new TVAL_node;
    t->next = NULL;
    tvalt.head = tvalt.top = t;
    t = NULL;
    delete t;
}

void initAINFL()   //数组表初始化
{
    AINFL_node *t = new AINFL_node;
    t->next = NULL;
    ainflt.head = ainflt.top = t;
    t = NULL;
    delete t;
}
void Origin_TVAL()    //类型表初始填入四项类型
{
    string a[4]={"i","d","c","b"};
    TVAL_node *q;
    for(int i=0;i<4;i++)
    {
    q=new TVAL_node;
    q->tp=a[i];
    tvalt.top->next=q;
    tvalt.top=q;
    q=NULL;
    delete q;
    }
}







bool istype(string &s)
{
    return (s == "int" || s == "char" || s == "bool");//待补充
}

int typebyte(string &s)
{
    if(s == "int")return 4;
    else if(s == "char")return 1;
    else if(s == "bool")return 1;//待补充
}



void valltable::fill_all_table(plotnode *&p,symbol_node *symn)    //填充活动记录、函数表、形参表、符号总表
{
    string var_cat;    //vn vf
    string type;    //类型（int char 等）
    int last_size;   //存储每次填充形参之前的vall表大小
    int cnt = 0;    //形参个数计数
    int level = level_cnt + 1;  //当前函数深度(其实c++都为0)
    isinfun = true;
    PFnode *f = new PFnode;
    f->level = this->level = level;  //函数表及活动记录层次
    f->off = 3;    //函数表区距
    f->entry = 0;  //暂且设置函数入口地址为0
    FPMnode *fpm = fpmt.top;  //      存储每次填充形参之前的符号表top指针
    int byte;       //记录每个标识符的存储单元数
    int vall_add;   //记录每个形参的off
    for(;!(p->name == "PT" && PT[p->num ] == ")");p = p->next)
    {
        if(p->name == "KT" && KT[p->num ] != "main")
        {
            type = KT[p->num ];  //存储当前类型
            var_cat = "vf";    //赋值形参
            if(p->next->name == "PT" && PT[p->next->num ] == "&") {p = p->next;var_cat = "vn";}   //如果是引用界符则更为换名形参
            if(p->next->name == "PT" && PT[p->next->num ] == "*") {p = p->next;}      //如果是指针界符，则不变
            byte = (var_cat == "vn" ? 2 : typebyte(KT[p->num ]));//如果是换名形参则为2
            vallnode a;
            a.name = IT[p->next->num ];      //IT的方法待修改
            a.add = -1;
            last_size = table.size();
            table.resize(last_size + byte,a);    //填充活动记录
            int vall_add = last_size;   //指向新存入单元
            fill_fpmt(a.name,type,var_cat,vall_add); //填写形参表
            cnt++;
        }
    }
    table[2].add = cnt; //参数个数
    f->fpm = fpm->next;   //使形参表指针指向新存的符号表内容
    f->num = cnt;      //修改形参个数
    f->next = NULL;
    symn->pf = f;   //修改函数标识符符号表的add值
    pft.top->next = f;
    pft.top = f;        //至此已经添加完新的函数表
    fill_symt_copy_fpm(fpm->next);  //至此已添加完符号表
    table.resize(table.size() + 1); //display表
    table[table.size() - 1].add = 0;
    f = NULL;
    delete f;


}




void initPFINFL()
{
    PFnode *p = new PFnode;
    p->next = NULL;
    pft.head = p;
    pft.top = pft.head;
    p = NULL;
    delete p;
}




void initFPMtable()
{
    FPMnode *p = new FPMnode;
    p->next = NULL;
    fpmt.head = p;
    fpmt.top = fpmt.head;
    p = NULL;
    delete p;
}

void fill_fpmt(string name,string type,string var_cat,int vall_add)
{
    FPMnode *p = new FPMnode;
    p->name = name;
    p->var_cat = var_cat;
    p->vall_add = vall_add;
    switch(type[0])
    {
        case 'i':p->tva = tvalt.head->next;break;
        case 'd':p->tva = tvalt.head->next->next;break;
        case 'c':p->tva = tvalt.head->next->next->next;break;
        case 'b':p->tva = tvalt.head->next->next->next->next;break;
        default :break;//待补充
    }
    p->next = NULL;
    fpmt.top->next = p;
    fpmt.top = p;
    p = NULL;
    delete p;
}

void fill_symt_copy_fpm(FPMnode *fpm)      //根据形参表指针复制符号表信息,指针指向当前需要复制的形参
{
    FPMnode *f = fpm;
    for(;f != NULL;f = f->next)
    {
        symbol_node *s = new symbol_node;
        s->name = f->name;
        s->typ = f->tva;
        s->cat = f->var_cat;
        s->vall_add = f->vall_add;
        s->pf = NULL;
//        s->ltp = NULL;
        s->next = NULL;
        symt.top->next = s;
        symt.top = s;
        s = NULL;
        delete s;
    }
}

void change_level_cnt(plotnode *p)
{
    if(p->name == "PT" && PT[p->num ] == "{")  //"{"
        level_cnt = level_cnt + 1;
    else if(p->name == "PT" && PT[p->num ] == "}") //"}"
    {
        level_cnt = level_cnt - 1;
        if(level_cnt == -1 && isinfun)   //若在函数内部,深度变为-1,则表示已不在函数内部
            {
                isinfun = false;
                current_vallt = NULL;
                delete current_vallt;
            }
    }
}





void fill_searcht(string name,symbol_node *symn,valltable *vallt)
{
    searcht.resize(searcht.size() + 1);
    searcht[searcht.size() - 1].copy_node(name,symn,vallt);
}


int get_vall_add_and_fill(symbol_node *symn)    //填写局部变量的vall_add值
{
    int vall_add = current_vallt->table.size();
    int byte = getbyte(symn);
    vallnode a;
    a.add = -1;
    a.name = symn->name;
    current_vallt->table.resize(current_vallt->table.size() + byte,a);
    return vall_add;
}

int getbyte(symbol_node *symn)
{
    if(symn->typ->tp == "i")return 4;
    else if(symn->typ->tp == "d")return 8;
    else if(symn->typ->tp == "c")return 1;
    else if(symn->typ->tp == "b")return 1;
    else if(symn->typ->tp == "a")
    {
        AINFL_node *p = symn->typ->aip;
        return (p->high - p->low + 1) * p->lenth;
    }
}


void create_valltable (string fun_name)
{
    if(find_searcht(fun_name) == -1)cout<<"ERROR:函数"<<fun_name<<"没有定义"<<endl;
    else
    {
        valltable a;
        if(vall_all.size() == 0)
        {
            a = *(searcht[find_searcht("main")].vallt);
            vall_all.resize(vall_all.size() + 1,a);
        }
        a = *(searcht[find_searcht(fun_name)].vallt);
        vall_all.resize(vall_all.size() + 1,a);
    }

}

int find_searcht(string s)
{
    int i;
    for(i = 0;i < searcht.size();i++)
    {
        if(searcht[i].name == s)return i;
    }
    if(i == searcht.size())cout<<"ERROR:当前没有"<<s<<"函数的记录!!!";
    return -1;
}

void fill_symbol_all(plotlist &ll)
{
    string ss;    //存储类型
    symbol_node *q;
    plotnode *p;
    p = ll.head->next;
    for(;p != NULL;p = p->next)
    {
        change_level_cnt(p);    //变更大括号深度,及是否在函数内部
        if(p->name == "KT" && KT[p->num ] != "return"&&p->next != NULL)
        {
            if(p->next->name == "KT" && KT[p->next->num ] == "main") //main函数
            {
                current_vallt = new valltable(level_cnt + 1);  //开始main函数活动记录
                q = new symbol_node;
                fill_searcht("main",q,current_vallt);   //填充索引表
                q->name = "main";
                q->cat = "f";
                q->next = NULL;
                q->vall_add = -1;
                switch(KT[p->num ][0])
                {
                    case 'i':q->typ = tvalt.head->next;break;
                    case 'd':q->typ = tvalt.head->next->next;break;
                    case 'c':q->typ = tvalt.head->next->next->next;break;
                    case 'b':q->typ = tvalt.head->next->next->next->next;break;
                    default :break;//待补充
                }
                p = p->next;    //指针指向main
                symt.top->next = q;
                symt.top = q;
                current_vallt->fill_all_table(p,q);     //填充活动记录,形参表,符号表及函数表
                q = NULL;
                delete q;
            }
            else if(p->next->name == "IT")
            {
                if(p->next->next->name == "PT" &&PT[p->next->next->num ] == "(") //普通函数
                {
                    current_vallt = new valltable(level_cnt + 1);  //开始函数活动记录
                    q = new symbol_node;
                    fill_searcht(IT[p->next->num ],q,current_vallt);
                    q->name = IT[p->next->num ];
                    q->cat = "f";
                    q->next = NULL;
                    q->vall_add = -1;
                    switch(KT[p->num ][0])
                    {
                        case 'i':q->typ = tvalt.head->next;break;
                        case 'd':q->typ = tvalt.head->next->next;break;
                        case 'c':q->typ = tvalt.head->next->next->next;break;
                        case 'b':q->typ = tvalt.head->next->next->next->next;break;
                        default :q->typ = NULL;break;//待补充
                    }
                    p = p->next;    //指针指向函数名
                    symt.top->next = q;
                    symt.top = q;
                    current_vallt->fill_all_table(p,q);
                    q = NULL;
                    delete q;
                }
                else if(p->next->next->name == "PT" &&PT[p->next->next->num ] == "[")//数组
                {
                    ss = KT[p->num];
                    fill_AINFL(ss,p);
                }
                else        //普通变量
                {
                     q = new symbol_node;
                     q->name = IT[p->next->num];
                     q->cat = "v";
                     q->pf = NULL;
                     q->next =  NULL;
                     switch(KT[p->num ][0])
                    {
                        case 'i':q->typ= tvalt.head->next;break;
                        case 'd':q->typ = tvalt.head->next->next;break;
                        case 'c':q->typ = tvalt.head->next->next->next;break;
                        case 'b':q->typ = tvalt.head->next->next->next->next;break;
                        default :break;//待补充
                    }
                    q->vall_add = isinfun ? get_vall_add_and_fill(q) : -1;
                    symt.top->next=q;
                    symt.top=q;
                    q=NULL;
                    delete q;
                }
            }
        }
        else if(p->name == "PT" && PT[p->num ] == ",")   //如果是逗号则表示并列
        {
            plotnode *pp = p;
            for(;pp->name != "KT";pp = pp->prior);
            ss = KT[pp->num ];
            if(p->next->name != "IT")cout<<"逗号后未检测到变量"<<endl;
            if(p->next->next->name == "PT" && PT[p->next->next->num ] == "[") //数组
            {
                fill_AINFL(ss,p);
            }
            else    //普通变量
            {
                q = new symbol_node;
                q->name = IT[p->next->num];
                q->cat = "v";
                q->pf = NULL;
                q->next =  NULL;
                switch(ss[0])
                {
                    case 'i':q->typ= tvalt.head->next;break;
                    case 'd':q->typ = tvalt.head->next->next;break;
                    case 'c':q->typ = tvalt.head->next->next->next;break;
                    case 'b':q->typ = tvalt.head->next->next->next->next;break;
                    default :break;//待补充
                }
                q->vall_add = isinfun ? get_vall_add_and_fill(q) : -1;
                symt.top->next = q;
                symt.top = q;
                q = NULL;
                delete q;
            }

        }
        else if(p->name == "IT" && p->next->name == "PT" && PT[p->next->num ] == "(") //正在调用函数
        {
            create_valltable(IT[p->num]);
            for(;!(p->name == "PT" && PT[p->num ] == ")");p = p->next);   //调整指针
        }

    }
}

void fill_AINFL(string s,plotnode *&p)
{
    symbol_node *q;
    q = new symbol_node;
    q->next = NULL;
    q->name = IT[p->next->num];
    q->cat = "t";
    q->pf = NULL;
    TVAL_node *t = new TVAL_node;
    t->next = NULL;
    t->tp = "a";
    AINFL_node  *a;
    a = new AINFL_node;
    a->next = NULL;
    a->low = 1;
    stringstream ss(CCT[p->next->next->next->num]);
    ss>>a->high;
    if(s == "int")a->lenth = 4;
    if(s == "double")a->lenth = 8;
    if(s == "char")a->lenth = 1;
    if(s == "bool")a->lenth = 1;
    //lenth_type[i]=a->lenth*a->high;
    //q->ltp=lenth_type;
    q->typ = t;
    t->aip = a;
    switch(s[0])
    {
        case 'i':a->tap = tvalt.head->next;break;
        case 'd':a->tap = tvalt.head->next->next;break;
        case 'c':a->tap = tvalt.head->next->next->next;break;
        case 'b':a->tap = tvalt.head->next->next->next->next;break;
        default :break;//待补充
    }
    if(isinfun)
        q->vall_add = get_vall_add_and_fill(q);
    else q->vall_add = -1;
    symt.top->next = q;
    symt.top = q;
    q = NULL;
    delete q;
    ainflt.top->next = a;
    ainflt.top = a;
    a=NULL;
    delete a;
    tvalt.top->next = t;
    tvalt.top = t;
    t = NULL;
    delete t;
    for(;!(PT[p->num] == "]" && p->name == "PT");p = p->next);
}

void printvall(vallnode v)
{
    if(v.name == "#")cout<<v.add;
    else cout<<v.name;
}

void printvall_all()
{
    for(int i = 0;i < vall_all.size();i++)
    {
        for(int j = 0;j < vall_all[i].table.size();j++)
        {
            printvall(vall_all[i].table[j]);
            cout<<endl;
        }
    }
}

class fourth
{
public:
    string var;
    int point;
    fourth(){var = "#";point = -1;}
    fourth(string var,int point):var(var),point(point){}
    ~fourth(){}
};

typedef struct
{
    string OT;  //操作符
    string sec;
    string thr;
    fourth four;
}quater;

void initSEM()
{
    SEM.resize(0);
}

void pushSEM(string s)
{
    SEM.push_back(s);
}

bool popSEM()
{
    if(SEM.size() == 0)return false;
    else
    {
        SEM.resize(SEM.size() - 1);
        return true;
    }
}

vector <quater> QT;
void initQT()
{
    QT.resize(0);
}


vector <int> if_num;    //统计正在递归使用的if四元式序号值
vector <int> while_num; //统计正在递归调用的while序号
vector <int> do_num;    //统计正在递归调用的do序号
int tnum=1;     //存放当前的t序号
int fnum =1;
string fun_name;    //存放当前函数名
int get_top_if()
{
    return if_num[if_num.size() - 1];
}
int get_top_while()
{
    return while_num[while_num.size() - 1];
}
int get_top_do()
{
    return do_num[do_num.size() - 1];
}
void do_if()
{
    quater *a = new quater;
    a->OT = "IF";
    a->sec = SEM[SEM.size() - 1];
    a->thr = "_";
    QT.push_back(*a);
    if_num.push_back(QT.size() - 1);   //将当前四元式序号记录,方便递归
    popSEM();
    a = NULL;
    delete a;

}

void do_else()
{
    quater *a = new quater;
    a->OT = "EL";
    a->sec = "_";
    a->thr = "_";
    QT.push_back(*a);
    QT[get_top_if()].four.point = QT.size();    //指针指向else的下一个四元式
    a = NULL;
    delete a;
}

void do_ifend()
{
    quater *a = new quater;
    a->OT = "IE";
    a->sec = "_";
    a->thr = "_";
    a->four.var = "_";
    QT.push_back(*a);
    if(QT[get_top_if()].four.point == -1)         //没有else,改变if的第四项指针
        QT[get_top_if()].four.point = QT.size() - 1;
    else
        QT[QT[get_top_if()].four.point - 1].four.point = QT.size() - 1;//有else改变else的第四项指针
    if_num.resize(if_num.size() - 1);       //if结束
    a = NULL;
    delete a;
}

void do_while()
{
    quater *a = new quater;
    a->OT = "WH";
    a->sec = "_";
    a->thr = "_";
    a->four.var = "_";
    QT.push_back(*a);
    while_num.resize(while_num.size() + 1,QT.size() - 1);
    a = NULL;
    delete a;
}

void do_do()
{
    quater *a = new quater;
    a->OT = "DO";
    a->sec = SEM[SEM.size() - 1];
    a->thr = "_";
    QT.push_back(*a);
    do_num.resize(do_num.size() + 1,QT.size() - 1);
    popSEM();
    a = NULL;
    delete a;

}

void do_whend()
{
    quater *a = new quater;
    a->OT = "WE";
    a->sec = "_";
    a->thr = "_";
    a->four.point = get_top_while() + 1;
    QT.push_back(*a);
    QT[get_top_do()].four.point = QT.size();
    while_num.resize(while_num.size() - 1);
    do_num.resize(do_num.size() - 1);
    a = NULL;
    delete a;
}

void do_cin()
{
    quater *a = new quater;
    a->OT = "CIN";
    symbol_node *p = searcht[find_searcht(fun_name)].symn;
    for(; p != NULL;p = p->next)
        if (p->name == w)break;
    a->sec = p->typ->tp;
    a->thr = "_";
    a->four.var = w;
    QT.push_back(*a);
    a = NULL;
    delete a;
}

void do_cout()
{
    quater *a = new quater;
    a->OT = "COUT";
    a->sec = "_";
    a->thr = "_";
    a->four.var = SEM[SEM.size() - 1];
    QT.push_back(*a);
    popSEM();
    a = NULL;
    delete a;
}


void do_push()
{
    pushSEM(w);
}


void do_arr()
{
    string s = SEM[SEM.size() - 1];
    s = s + "[" + w + "]";
    popSEM();
    pushSEM(s);
}
string turn_string(int x)
{
    string a;
    stringstream ss;
    ss<<x;
    ss>>a;
    return a;
}
void do_and()
{
    quater c;
    string a="t";
    c.OT="&&";
    c.sec=SEM[SEM.size() - 1-1];
    c.thr=SEM[SEM.size() - 1];
    c.four.var=a+turn_string(tnum);
    tnum=tnum+1;
    popSEM();
    popSEM();
    QT.push_back(c);
    pushSEM(c.four.var);
}
void do_or()
{
    quater c;
    string a="t";
    c.OT="&&";
    c.sec=SEM[SEM.size() - 1-1];
    c.thr=SEM[SEM.size() - 1];
    c.four.var=a+turn_string(tnum);
    tnum=tnum+1;
    popSEM();
    popSEM();
    QT.push_back(c);
    pushSEM(c.four.var);
}
void do_not()
{
    quater c;
    string a="t";
    c.OT="!";
    c.sec=SEM[SEM.size() - 1];
    c.thr="_";
    c.four.var=a+turn_string(tnum);
    tnum=tnum+1;
    popSEM();
    popSEM();
    QT.push_back(c);
    pushSEM(c.four.var);
}
void do_add()
{
    quater c;
    string a="t";
    c.OT="+";
    c.sec=SEM[SEM.size() - 1-1];
    c.thr=SEM[SEM.size() - 1];
    c.four.var=a+turn_string(tnum);
    popSEM();
    popSEM();
    QT.push_back(c);
    pushSEM(c.four.var);
    tnum=tnum+1;
}
void do_sub()
{
    quater c;
    string a="t";
    c.OT="-";
    c.sec=SEM[SEM.size() - 1-1];
    c.thr=SEM[SEM.size() - 1];
    c.four.var=a+turn_string(tnum);
    popSEM();
    popSEM();
    tnum=tnum+1;
    QT.push_back(c);
    pushSEM(c.four.var);
}
void do_mul()
{
    quater c;
    string a="t";
    c.OT="*";
    c.sec=SEM[SEM.size() - 1-1];
    c.thr=SEM[SEM.size() - 1];
    c.four.var=a+turn_string(tnum);
    tnum=tnum+1;
    popSEM();
    popSEM();
    QT.push_back(c);
    pushSEM(c.four.var);
}
void do_div()
{
    quater c;
    string a="t";
    c.OT="/";
    c.sec=SEM[SEM.size() - 1-1];
    c.thr=SEM[SEM.size() - 1];
    c.four.var=a+turn_string(tnum);
    tnum=tnum+1;
    popSEM();
    popSEM();
    QT.push_back(c);
    pushSEM(c.four.var);
}
void do_less_than()
{
    quater c;
    string a="t";
    c.OT="<";
    c.sec=SEM[SEM.size() - 1-1];
    c.thr=SEM[SEM.size() - 1];
    c.four.var=a+turn_string(tnum);
    tnum=tnum+1;
    popSEM();
    popSEM();
    QT.push_back(c);
    pushSEM(c.four.var);
}
void do_more_than()
{
    quater c;
    string a="t";
    c.OT=">";
    c.sec=SEM[SEM.size() - 1-1];
    c.thr=SEM[SEM.size() - 1];
    c.four.var=a+turn_string(tnum);
    tnum=tnum+1;
    popSEM();
    popSEM();
    QT.push_back(c);
    pushSEM(c.four.var);
}
void do_less_than_or_equal()
{
    quater c;
    string a="t";
    c.OT="<=";
    c.sec=SEM[SEM.size() - 1-1];
    c.thr=SEM[SEM.size() - 1];
    c.four.var=a+turn_string(tnum);
    tnum=tnum+1;
    popSEM();
    popSEM();
    QT.push_back(c);
    pushSEM(c.four.var);
}
void do_more_than_equal()
{
    quater c;
    string a="t";
    c.OT="<=";
    c.sec=SEM[SEM.size() - 1-1];
    c.thr=SEM[SEM.size() - 1];
    c.four.var=a+turn_string(tnum);
    tnum=tnum+1;
    popSEM();
    popSEM();
    pushSEM(c.four.var);
}
void do_equal_equal()
{
    quater c;
    string a="t";
    c.OT="==";
    c.sec=SEM[SEM.size() - 1-1];
    c.thr=SEM[SEM.size() - 1];
    c.four.var=a+turn_string(tnum);
    tnum=tnum+1;
    popSEM();
    popSEM();
    QT.push_back(c);
    pushSEM(c.four.var);
}

void do_equal()
{
    quater c;
    string a="t";
    c.OT="=";
    c.sec=SEM[SEM.size() - 1];
    c.thr="_";
    c.four.var=SEM[SEM.size() - 1-1];
    popSEM();
    popSEM();
    QT.push_back(c);
}

typedef struct
{
    string fun_name;
    int add;
    int num;
}fun_add_table_node;
vector <fun_add_table_node> fun_add_table;
int find_fun_add(string name)
{
    for(int i = 0;i < fun_add_table.size();i++)
        if(fun_add_table[i].fun_name == name)return fun_add_table[i].add;
    return -1;
}

int find_var_num(string name)
{
    for(int i = 0;i < fun_add_table.size();i++)
        if(fun_add_table[i].fun_name == name)return fun_add_table[i].num;
    return -1;
}

int find_fun(string name)
{
    for(int i = 0;i < fun_add_table.size();i++)
        if(fun_add_table[i].fun_name == name)return i;
    return -1;
}


int var_num;    //形参个数
int ismain;     //是否在主函数内
vector <int> ret_add;   //返回地址
void do_in()
{
    quater c;
    c.OT = "PUSH";
    c.sec = "_";
    c.thr = "_";
    c.four.var = SEM.back();
    popSEM();
    QT.push_back(c);
}

void do_fun2()
{
    quater c;
    c.OT = "PUSH";
    c.sec = "_";
    c.thr = "_";
    QT.push_back(c);
   // pushSEM(w);
    ret_add.push_back(QT.size() - 1);
}

void do_fun_end()   //调用函数结束
{
    quater c;
    c.OT = "FUN";
    c.sec = SEM[SEM.size() - 1];
    c.thr = "_";
    c.four.point = find_fun_add(SEM[SEM.size() - 1]);
    QT.push_back(c);
    QT[ret_add[ret_add.size() - 1]].four.point = QT.size();
    popSEM();
}

void do_over()
{
    string s = "f" + turn_string(fnum);
    quater c;
    c.OT = "POP";
    c.sec = "_";
    c.thr = "_";
    c.four.var = s;
    QT.push_back(c);
    ret_add.resize(ret_add.size() - 1);
    fnum = fnum + 1;
    pushSEM(s);

}




void do_var()
{
    pushSEM(w);
    var_num = var_num + 1;
}

void do_fun()
{
    var_num = 0;
    quater c;
    c.OT = "FUN";
    c.sec = w;
    c.thr = "_";
    c.four.var = "_";
    QT.push_back(c);
    if(w == "main")ismain = 1;
    else
    {
        ismain =0;
        fun_add_table_node n;
        n.fun_name = w;
        n.add = QT.size();
        n.num = 0;
        fun_add_table.push_back(n);
    }

}

void do_define()
{
    quater c;
    if(!ismain)
        fun_add_table[fun_add_table.size() - 1].num = var_num;
    for(int i = 0;i < var_num;i++)
    {
        c.OT = "POP";
        c.sec = "_";
        c.thr = "_";
        c.four.var = SEM[SEM.size() - 1];
        QT.push_back(c);
        popSEM();
    }
}

void do_ret()
{
    quater c;
    if(ismain)
    {
        c.OT = "RET";
        c.sec = "_";
        c.thr = "_";
        c.four.var = "_";
        QT.push_back(c);
    }
    else
    {
        c.OT = "POP";
        c.sec = "_";
        c.thr = "_";
        c.four.var = "add";
        QT.push_back(c);
        c.OT = "PUSH";
        c.sec = "_";
        c.thr = "_";
        c.four.var = SEM[SEM.size() - 1];
        QT.push_back(c);
        c.OT = "RET";
        c.sec = "_";
        c.thr = "_";
        c.four.var = "add";
        QT.push_back(c);
        popSEM();
    }

}


void show_QT(quater l)
{
    if(l.four.var=="#")
    cout<<"("<<l.OT<<","<<l.sec<<","<<l.thr<<","<<l.four.point<<")"<<endl;
    else
    cout<<"("<<l.OT<<","<<l.sec<<","<<l.thr<<","<<l.four.var<<")"<<endl;
}

void show_all_QT()
{
    for(int i = 0;i < QT.size();i++)
    {
        cout<<i<<ends<<ends;
        show_QT(QT[i]);
    }
}
bool take_action(string name)
{
    if(name == "do(+)")do_add();
    else if(name == "do(-)")do_sub();
    else if(name == "do(*)")do_mul();
    else if(name == "do(/)")do_div();
    else if(name == "do(<)")do_less_than();
    else if(name == "do(>)")do_more_than();
    else if(name == "do(<=)")do_less_than_or_equal();
    else if(name == "do(>=)")do_more_than_equal();
    else if(name == "do(==)")do_equal_equal();
    else if(name == "do(fun)")do_fun();
    else if(name == "do(ret)")do_ret();
    else if(name == "do(=)")do_equal();
    else if(name == "do(push)")do_push();
    else if(name == "do(while)")do_while();
    else if(name == "do(do)")do_do();
    else if(name == "do(we)")do_whend();
    else if(name == "do(if)")do_if();
    else if(name == "do(el)")do_else();
    else if(name == "do(ie)")do_ifend();
    else if(name=="do(cin)")do_cin();
    else if(name=="do(cout)")do_cout();
    else if(name=="do(arr)")do_arr();
    else if(name == "do(in)")do_in();
    else if(name == "do(fun2)")do_fun2();
    else if(name == "do(fe)")do_fun_end();
    else if(name == "do(over)")do_over();
    else if(name == "do(var)")do_var();
    else if(name == "do(def)")do_define();
    else if(name == "do(&&)")do_and();
    else if(name == "do(||)")do_or();
    else if(name == "do(!)")do_not();
    else return false;
    return true;
}


//四元式优化
bool istempvar(string s)
{
    return (s[0] == 't');
}
bool issomeOT(string s)
{
    return (s == "+" || s == "-" || s == "*" || s == "/" || s == "=" || s == "==" || s == "<=" || s == ">=" || s == "<" || s == ">" || s == "&&" || s == "||" || s == "!");
}
bool isnum(char s)
{
    return (s >= 48 && s <= 57);
}
double doOT(string ot,double x,double y)
{
    if(ot == "+")return x + y;
    if(ot == "-")return x - y;
    if(ot == "*")return x * y;
    if(ot == "/")return x / y;
    if(ot == "<")return x < y;
    if(ot == "<=")return x <= y;
    if(ot == ">=")return x >= y;
    if(ot == ">")return x > y;
    if(ot == "==")return x == y;
    if(ot == "&&")return x && y;
    if(ot == "||")return x || y;

}

string turn_string(double x)
{
    string a;
    stringstream ss;
    ss<<x;
    ss>>a;
    return a;
}


double turn_double(string x)
{
    double a;
    string res=x;
    stringstream ss;
    ss << res;
    ss >> a;
    return a;
}


vector <quater> QT_better;

typedef struct
{
    vector <quater> mod;
}module;
vector <module> allmodule;  //模块集


class DAGnode
{
public:
    string OT;  //运算符
    string main_sign;   //主标记
    vector <string> sub_sign;   //子标记
    int son1,son2;  //左右结点
    DAGnode(){sub_sign.resize(0);OT = "#";son1 = son2 = -1;}
    ~DAGnode(){}
    void add_sub_sign(string s);
    void delete_sub_sign(string s);
};

vector <DAGnode> DAGgraph;
void create_QTbetter();
void create_DAGnode(quater q);
void fill_sub_sign_equal(DAGnode d);

void DAGnode::add_sub_sign(string s)        //添加附加标记
{
    if(istempvar(main_sign) && !(istempvar(s)))
    {
        string ss = main_sign;
        main_sign = s;
        s = ss;
    }
    sub_sign.push_back(s);
}

void DAGnode::delete_sub_sign(string s)
{
    if(main_sign == s)return;
    else
    {
        for(int i = 0;i < sub_sign.size();i++)
        {
            if(sub_sign[i] == s)sub_sign.erase(sub_sign.begin() + i);
            return;
        }
    }
}
int find_DAG(string s)
{
    for(int i = DAGgraph.size() - 1;i >= 0;i--)
    {
        if(DAGgraph[i].main_sign == s)return i;
        else
        {
            for(int j = 0;j < DAGgraph[i].sub_sign.size();j++)
                if(DAGgraph[i].sub_sign[j] == s)return i;
        }
    }
    return -1;
}

int find_DAG(string s,int x)        //找到一个异于刚刚操作过的点
{
    for(int i = DAGgraph.size() - 1;i >= 0;i--)
    {
        if(DAGgraph[i].main_sign == s && i != x)return i;
        else
        {
            for(int j = 0;j < DAGgraph[i].sub_sign.size();j++)
                if(DAGgraph[i].sub_sign[j] == s && i != x)return i;
        }
    }
    return -1;
}

int find_DAG(string ot,int son1,int son2)
{
    for(int i = DAGgraph.size() - 1;i >= 0;i--)
    {
        if(DAGgraph[i].OT == ot && DAGgraph[i].son1 == son1 && DAGgraph[i].son2 == son2)
            return i;
    }
    return -1;
}

module create_mod(int head,int tail)
{
    module m;
    m.mod.resize(0);
    for(int i = head;i < tail;i++)
    {
        m.mod.push_back(QT[i]);
    }
    return m;
}


void divide_module()
{
    module m;
    vector <int> div_state(QT.size(),0);
    for(int i = 0;i < QT.size();i++)
        if(QT[i].four.point != -1)
        {
            if(i + 1 < QT.size())
                div_state[i + 1] = 1;
            if(QT[i].four.point < QT.size())
                div_state[QT[i].four.point] = 1;
        }
        else if(QT[i].OT == "RET")
        {
            if(i + 1 < QT.size())
                div_state[i + 1] = 1;
        }
    int head = 0;
    int i;
    for(i = 0;i < div_state.size();i++)
    {
        if(div_state[i]  == 1)
        {
            m = create_mod(head,i);
            allmodule.push_back(m);
            head = i;
        }
    }
    m = create_mod(head,QT.size());
    allmodule.push_back(m);
}


void create_graph_fill_QT_better(module m)
{
    DAGgraph.resize(0);
    int i;
    for(i = 0;i < m.mod.size();i++)
    {
        if(issomeOT(m.mod[i].OT))break;
        else QT_better.push_back(m.mod[i]);
    }
    for(;i < m.mod.size();i++)
    {
        if(!issomeOT(m.mod[i].OT))break;
        else create_DAGnode(m.mod[i]);
    }
    create_QTbetter();
    for(;i < m.mod.size();i++)
    {
        QT_better.push_back(m.mod[i]);
    }
}


void create_DAGnode(quater q)
{
    int current;
    int son1,son2;
    if(q.OT == "=") //A=B
    {
        if(find_DAG(q.sec) == -1)       //如果B没定义过,则新建结点
        {
            DAGnode p;
            p.main_sign = q.sec;
            p.add_sub_sign(q.four.var);
            DAGgraph.push_back(p);
            current = DAGgraph.size() - 1;
        }
        else
        {
            DAGgraph[find_DAG(q.sec)].add_sub_sign(q.four.var);//否则附加到之前的节点后
            current = find_DAG(q.sec);
        }
        if(find_DAG(q.four.var,current) != -1)      //如果A已定义过,则删掉之前的,主不删
            DAGgraph[find_DAG(q.four.var,current)].delete_sub_sign(q.four.var);

    }
    else if(isnum(q.sec[0]) && isnum(q.thr[0]))
    {
        double c = doOT(q.OT,turn_double(q.sec),turn_double(q.thr));
        string s = turn_string(c);
        if(find_DAG(s) == -1)
        {
            DAGnode p;
            p.main_sign = s;
            p.add_sub_sign(q.four.var);
            DAGgraph.push_back(p);
            current = DAGgraph.size() - 1;
        }
        else
        {
            DAGgraph[find_DAG(s)].add_sub_sign(q.four.var);
            current = find_DAG(s);
        }
        if(find_DAG(q.four.var,current) != -1)
            DAGgraph[find_DAG(q.four.var,current)].delete_sub_sign(q.four.var);
    }
    else if(q.OT == "!")
    {
        if(find_DAG(q.sec) == -1)
        {
            DAGnode p1;
            p1.main_sign = q.sec;
            DAGgraph.push_back(p1);
            son1 = DAGgraph.size() - 1;
        }
        else son1 = find_DAG(q.sec);
        son2 = -1;
        if(find_DAG(q.OT,son1,son2) == -1)
        {
            DAGnode p;
            p.main_sign = q.four.var;
            p.OT = q.OT;
            p.son1 = son1;
            p.son2 = son2;
            DAGgraph.push_back(p);
            current = DAGgraph.size() - 1;
        }
        else
        {
            DAGgraph[find_DAG(q.OT,son1,son2)].add_sub_sign(q.four.var);
            current = find_DAG(q.OT,son1,son2);
        }
        if(find_DAG(q.four.var,current) != -1)
            DAGgraph[find_DAG(q.four.var,current)].delete_sub_sign(q.four.var);
    }
    else
    {
        if(find_DAG(q.sec) == -1)
        {
            DAGnode p1;
            p1.main_sign = q.sec;
            DAGgraph.push_back(p1);
            son1 = DAGgraph.size() - 1;
        }
        else son1 = find_DAG(q.sec);
        if(find_DAG(q.thr) == -1)
        {
            DAGnode p2;
            p2.main_sign = q.thr;
            DAGgraph.push_back(p2);
            son2 = DAGgraph.size() - 1;
        }
        else son2 = find_DAG(q.thr);
        if(find_DAG(q.OT,son1,son2) == -1)
        {
            DAGnode p;
            p.main_sign = q.four.var;
            p.son1 = son1;
            p.son2 = son2;
            p.OT = q.OT;
            DAGgraph.push_back(p);
            current = DAGgraph.size() - 1;
        }
        else
        {
            DAGgraph[find_DAG(q.OT,son1,son2)].add_sub_sign(q.four.var);
            current = find_DAG(q.OT,son1,son2);
        }
        if(find_DAG(q.four.var,current) != -1)
            DAGgraph[find_DAG(q.four.var,current)].delete_sub_sign(q.four.var);
    }

}



void create_QTbetter()
{
    quater q;
    for(int i = 0;i < DAGgraph.size();i++)
    {
        quater q;
        if(DAGgraph[i].OT == "#")
            fill_sub_sign_equal(DAGgraph[i]);
        else if(DAGgraph[i].OT == "!")
        {
            q.OT = "!";
            q.sec = DAGgraph[DAGgraph[i].son1].main_sign;
            q.thr = "_";
            q.four.var = DAGgraph[i].main_sign;
            q.four.point = -1;
            QT_better.push_back(q);
            fill_sub_sign_equal(DAGgraph[i]);
        }
        else
        {
            q.OT = DAGgraph[i].OT;
            q.sec = DAGgraph[DAGgraph[i].son1].main_sign;
            q.thr = DAGgraph[DAGgraph[i].son2].main_sign;
            q.four.var = DAGgraph[i].main_sign;
            q.four.point = -1;
            QT_better.push_back(q);
            fill_sub_sign_equal(DAGgraph[i]);
        }
    }
}


void show_all_QT_better()
{
    cout<<"DAG优化后的四元式组为:"<<endl;
    for(int i = 0;i < QT_better.size();i++)
    {
        cout<<i<<ends<<ends;
        show_QT(QT_better[i]);
    }
}


void fill_sub_sign_equal(DAGnode d)
{
    quater q;
    for(int i = 0;i < d.sub_sign.size();i++)
    {
        if(!istempvar(d.sub_sign[i]))
        {
            q.OT = "=";
            q.sec = d.main_sign;
            q.thr = "_";
            q.four.var = d.sub_sign[i];
            q.four.point = -1;
            QT_better.push_back(q);
        }
    }
}

void change_point_QT_better()
{
    vector <int> if_t;
    if_t.resize(0);
    vector <int> wh_t;
    wh_t.resize(0);
    vector <int> do_t;
    do_t.resize(0);
    for(int i = 0;i < QT_better.size();i++)
    {
        if(QT_better[i].OT == "IF")
        {
            if_t.push_back(i);
            QT_better[i].four.point = -1;
        }
        else if(QT_better[i].OT == "EL")
        {
            QT_better[if_t[if_t.size() - 1]].four.point = i + 1;
        }
        else if(QT_better[i].OT == "IE")
        {
            if(QT_better[if_t[if_t.size() - 1]].four.point == -1)
                QT_better[if_t[if_t.size() - 1]].four.point = i;
            else
                QT_better[QT_better[if_t[if_t.size() - 1]].four.point - 1].four.point = i;
            if_t.resize(if_t.size() - 1);
        }
        else if(QT_better[i].OT == "WH")
        {
            wh_t.push_back(i);
        }
        else if(QT_better[i].OT == "DO")
        {
            do_t.push_back(i);
        }
        else if(QT_better[i].OT == "WE")
        {
            QT_better[i].four.point = wh_t[wh_t.size() - 1] + 1;
            QT_better[do_t[do_t.size() - 1]].four.point = i + 1;
            wh_t.resize(wh_t.size() - 1);
            do_t.resize(do_t.size() - 1);
        }
        else if(QT_better[i].OT == "FUN")
        {
            if(QT_better[i].four.point == -1)
            {
                fun_add_table[find_fun(QT_better[i].sec)].add = i + 1;
            }
            else
            {
                QT_better[i - find_var_num(QT_better[i].sec) - 1].four.var = turn_string(i + 1);
                QT_better[i].four.point = find_fun_add(QT_better[i].sec);

            }


        }

    }

}


void DAG_better()
{
    divide_module();

   for(int i = 0;i < allmodule.size();i++)
   {
       create_graph_fill_QT_better(allmodule[i]);
   }
    change_point_QT_better();
}

void show_cifa(plotnode *p)
{
    for(int i=0;p!=NULL;p=p->next)
        cout << "<" << p->name << " " << p->num << ">";
    cout << endl;
}

void cifa(scan *s)
{
    ifstream infile;
    string str;
    infile.open("test.txt");
    stringstream buffer;
    buffer << infile.rdbuf();
    str = buffer.str();
    cout << str << endl;

    str = str + "\n#";
    string token="";
    char ch_before;
    int state = 1;
    int state_before;
    int i = 0,j = 0,hang1=0,hang2=0,ff=0,fff=0;
    char ch;
    plotnode *p;
    s->tL.inilist("tL",0);
    s->tA.inilist("tA",0);
    while((ch = str[i]) != '#')
    {
        state_before = state;
        state = s->state_change(state,ch);
        if(state != 1)
            if(state)
                {token = token + ch;i++;}
            else
            {
                s->state_token(state_before,token);
                state = 1;
                fff = 1;
                token.clear();
            }
        else {i++;ff = 1;}
        if(ch == '\n')
        {
            hang2++;
            if(fff == 1) {hang1++;fff = 0;}
            hang = hang2-hang1+1;
            p = s->tL.head;
            /*plotnode *q;
            q = s->tL.head;
            for(;q!=NULL;q=q->next)
                cout << "<" << q->name << " " << q->num << ">";
            cout << endl;*/
            if(p->next != NULL)
            {

                fill_symbol_all(s->tL);//cout << "aoligei" << endl;
            }
            s->tL.clr();
            s->tL.inilist("tL",0);
            ch_before = ch;
        }
    }
    cout << endl;
}

void show_PFINFL()
{
    PFnode *p = pft.head->next;
    if(pft.head->next == NULL)
        cout<<"当前函数表中没有内容存储"<<endl;
    else
    {
        cout<<"以下展示函数表内容："<<endl;
        cout<<"层次号    "<<"区距    "<<"参数个数  "<<"入口地址  "<<"参数表  "<<endl;
        for(;p != NULL;p = p->next)
        {
            cout<<setw(12)<<p->level<<setw(8)<<p->off<<setw(10)<<p->num<<setw(5)<<p->entry<<"    ";
            if(p->fpm != NULL)cout<<"fpm" << endl;
            else cout<<"null"<<endl;
        }
        cout<<"函数表已展示完毕!!"<<endl;
    }
}

void show_FPMtable()
{
    FPMnode *p = fpmt.head->next;
    if(fpmt.head->next == NULL)
        cout<<"当前形参表中没有内容存储"<<endl;
    else
    {
        cout<<"以下展示形参表内容："<<endl;
        cout<< std::left << setw(12) << "形参名"<<std::left << setw(12) << "类型表"<<std::left << setw(12) << "参数种类"<<std::left << setw(12) << "地址"<<endl;
        for(;p != NULL;p = p->next)
        {
            cout<<std::left << setw(12) << p->name<<std::left << setw(12) << p->tva->tp<<std::left << setw(12) << p->var_cat<<std::left << setw(12) << p->vall_add<<endl;
        }
        cout<<"形参表已展示完毕!!"<<endl;
    }
}

void show_seacht()
{
    if(searcht.size() == 0)
        cout<<"当前函数索引表中没有内容存储"<<endl;
    else
    {
        cout<<"以下展示索引表内容："<<endl;
        cout<<"函数名    "<<endl;
        for(int i = 0;i < searcht.size();i++)
        {
            cout<<searcht[i].name<<endl;
        }
        cout<<"索引表已展示完毕!!"<<endl;
    }
}

void show_AINFL()
{
    AINFL_node *a=new AINFL_node;
    a=ainflt.head->next;
    cout<<"数组表"<<endl;
    cout<<std::left<<setw(10)<<"数组上界"<<" "<<setw(8)<<"数组下界"<<" "<<setw(10)<<"元素类型"<<" "<<setw(10)<<"字节长度"<<endl;
    for(;a!=NULL;a=a->next)
    {cout<<std::left<<setw(15)<<a->high<<setw(10)<<a->low<<setw(8)<<a->tap->tp<<setw(5)<<a->lenth<<endl;}
    a=NULL;
    delete a;
}
void show_TVAL()
{
    TVAL_node *v=new TVAL_node;
    v=tvalt.head->next;
    cout<<"类型表"<<endl;
    cout<<std::left<<setw(10)<<"标识符类型"<<" "<<setw(8)<<"Tpoint"<<endl;
    for(;v!=NULL;v=v->next)
    {    if(v->aip!=NULL)
         {cout<<std::left<<setw(10)<<v->tp<<setw(10)<<"ain"<<endl;}
         else
         {cout<<std::left<<setw(10)<<v->tp<<setw(10)<<"null"<<endl;}}
    v=NULL;
    delete v;
}
void show_symbol()
{
    symbol_node *t=new symbol_node;
    t=symt.head->next;
    cout<<"符号表"<<endl;
    cout<<std::left<<setw(5)<<"元素名"<<" "<<setw(8)<<"元素类型"<<" "<<setw(8)<<"元素种类"<<" "<<setw(5)<<"地址"<<endl;
    for(;t!=NULL;t=t->next)
    {if(t->vall_add==-1)
    cout<<std::left<<setw(8)<<t->name<<setw(10)<<t->typ->tp<<setw(8)<<t->cat<<setw(5)<<"pf"<<endl;
     if(t->cat=="t" && t->vall_add!=-1)
    cout<<std::left<<setw(8)<<t->name<<setw(10)<<t->typ->tp<<setw(8)<<t->cat<<setw(5)<<t->vall_add<<endl;
     if(t->vall_add!=-1 &&t->cat!="t")
    cout<<std::left<<setw(8)<<t->name<<setw(10)<<t->typ->tp<<setw(8)<<t->cat<<setw(5)<<t->vall_add<<endl;
    }
    t=NULL;
    delete t;
    show_TVAL();
    show_AINFL();
    show_seacht();
    show_PFINFL();
    show_FPMtable();
}

void show_all(scan *s)
{
    int a;
    cout<<"请输入你要查看的内容："<<endl;
    cout<<"                     0.词法分析                            "<<endl;
    cout<<"                     1.符号表                              "<<endl;
    cout<<"                     2.四元式                              "<<endl;
    cout<<"                     3.优化四元式                          "<<endl;
    cout<<"                     4.退出                                "<<endl;
    cin>>a;
    switch (a)
    {
        case 0 :  show_cifa(s->tA.head->next);show_all(s);break;
        case 1 :  show_symbol();show_all(s);break;
        case 2:  show_all_QT();show_all(s);break;
        case 3 :  show_all_QT_better();show_all(s);break;
        case 4 :  cout<<"退出";break;
        default : cout<<"输入无效";
    }
}


int main()
{
    initPFINFL();
    initFPMtable();
    initsymt();
    initTVAL();
    Origin_TVAL();
    initAINFL();
    vall_all.resize(0);
    searcht.resize(0);
    allmodule.resize(0);

    getN(&vn);
    getT(&vt);
    getpRules(&vn);
    getN(&vn1);
    getpRules1(&vn1);
    getFirst(&vn);
    getFollow(&vn);
    analysisTab();
    tab[getVnPos("U",vn)][getVtPos("(",vt)] = "U%V2?V1?#";
    scan s;
    plotnode *p;
    cifa(&s);

    if(vall_all.size() == 0)
        vall_all.push_back(*searcht[find_searcht("main")].vallt);


 /*   for(int i=0;i<vn.size();i++)
    {
        for(int j=0;j<vn.at(i).p.size();j++)
        {
            cout<<vn.at(i).p.at(j)<<endl;
        }
    }
    int  a=getVnPos("S",vn);
    int b=getVtPos("void",vt);
    cout<<a<<"   "<<b<<endl;
    string ss=getrulefirst(vn.at(5).p.at(0));
    cout<<ss<<endl;
    for(int i=0;i<vn.size();i++)
    {
        cout<<vn.at(i).symbol<<" :";
        for(int j=0;j<vn.at(i).first.size();j++)
        {
            cout<<vn.at(i).first.at(j)<<"  ";
        }
        cout<<endl;
    }
    int c=getSizerule(vn.at(14).p.at(1));
    cout<<c<<endl;
    string d=getV(2,vn.at(3).p.at(1));
    cout<<d<<endl;
    for(int i=0;i<vn.size();i++)
    {
        cout<<vn.at(i).symbol<<" :";
        for(int j=0;j<vn.at(i).follow.size();j++)
        {
            cout<<vn.at(i).follow.at(j)<<"  ";
        }
        cout<<endl;
    }
    cout<<getV(1,vn.at(5).p.at(1));
    cout << endl;
    for(int i=0;i<vn.size();i++)
    {
        cout << vn.at(i).symbol << " ";
    }
    cout << endl;
    for(int i=0;i<vt.size();i++)
    {
        cout << vt.at(i).vt << " ";
    }
    cout << endl;
    for(int i=0;i<vn.size();i++)
    {
        for(int j=0;j<vt.size()+1;j++)
            cout << right << setw(40) << tab.at(i).at(j) << " ";
        cout << endl;
    }cout << "666" << endl;*/
    if(yufa(s.tA.head->next)) cout << "true" << endl;
    else cout << "false" << endl;
    show_all_QT();
    DAG_better();
    show_all(&s);
    cout<<endl;
    return 0;
}



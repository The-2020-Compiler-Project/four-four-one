typedef struct AINFL_node     //数组表
{
     int low,high,lenth;
     AINFL_node *next;
     struct TVAL_node * tap;
}AINFL_node;
typedef struct            //数组表结点
{
    AINFL_node *head;
    AINFL_node *top;
}AINFL;
typedef struct TVAL_node
{
     string tp;     //填表就等于你接受到的关键字
     AINFL_node *aip;   //指向数组表
     TVAL_node *next;
}TVAL_node;
typedef struct TVAL           //类型表定义
{
    TVAL_node *top;
    TVAL_node *head;
}TVAL;

//符号表数据结构
typedef struct symbol_node
{
    string name;
    TVAL_node *typ;         //指向类型表或者
    string cat;          //指向类型编号      //数组指向长度表，函数指向函数表
    symbol_node *next;       //next
    PFnode *pf;              //函数标识符指向函数表
    //int *ltp;                //数组或结构体指向长度
    int vall_add;       //函数形参或者变量指向vall表
}symbol_node;
typedef struct
{
    symbol_node *head;     //队头指针
    symbol_node *top;    //队尾指针
}symbol_table;


typedef struct plotnode
{
    string name;
    int num;
    plotnode *next;
    plotnode *prior;
}plotnode;

class plotlist
{
    public:
        plotnode *head;
        plotnode *last;
        plotlist(){}
        void inilist();
        void add(string name,int num);
};

void plotlist::inilist()//初始化链表
{
    head = new plotnode;
    last = head;
    head->next = NULL;
    head->prior = NULL;
}

void plotlist::add(string name,int num)//表尾添加数据
{
    plotnode *p;
    p = last;
    last = new plotnode;
    last->name = name;
    last->prior = p;
    last->num = num;
    last->next = NULL;
    p->next = last;
}
string KT[7] = {"int","char","double","if","return","main","cout"};
string PT[12] = {"(",",","&",")","{",";","[","]","=","<","}","<<"};
string IT[6] = {"max","x","y","c","a","d"};
string CCT[2]= {"1","2"};


plotlist ll1,ll2,ll3,ll4,ll5,ll6,ll7;


void initsymt()
{
    symbol_node *p =new symbol_node;
    p->next = NULL;
    symt.head = symt.top = p;
    p = NULL;
    delete p;
}

void initTVAL()
{
    TVAL_node *t = new TVAL_node;
    t->next = NULL;
    tvalt.head = tvalt.top = t;
    t = NULL;
    delete t;
}

void initAINFL()   //数组表初始化
{
    AINFL_node *t = new AINFL_node;
    t->next = NULL;
    ainflt.head = ainflt.top = t;
    t = NULL;
    delete t;
}
void Origin_TVAL()    //类型表初始填入四项类型
{
    string a[4]={"i","d","c","b"};
    TVAL_node *q;
    for(int i=0;i<4;i++)
    {
    q=new TVAL_node;
    q->tp=a[i];
    tvalt.top->next=q;
    tvalt.top=q;
    q=NULL;
    delete q;
    }
}


int main()
{
    vall_all.resize(0);
    searcht.resize(0);
    ll1.inilist();
    ll2.inilist();
    ll3.inilist();
    ll4.inilist();
    ll5.inilist();
    ll6.inilist();
    ll7.inilist();
    initPFINFL();
    initFPMtable();
    initsymt();
    initTVAL();
    Origin_TVAL();
    initAINFL();
    //ll1.add("KT",1);ll1.add("IT",1);ll1.add("PT",1);ll1.add("IT",2);ll1.add("PT",2);ll1.add("KT",1);ll1.add("IT",3);ll1.add("PT",4);
    ll1.add("KT",1);ll1.add("IT",1);ll1.add("PT",1);ll1.add("KT",1);ll1.add("IT",2);ll1.add("PT",2);ll1.add("KT",1);ll1.add("IT",3);ll1.add("PT",4);
    ll2.add("PT",5);ll2.add("KT",1);ll2.add("IT",5);ll2.add("PT",9);ll2.add("IT",2);ll2.add("PT",6);
    ll3.add("KT",4);ll3.add("PT",1);ll3.add("IT",2);ll3.add("PT",10);ll3.add("IT",3);ll3.add("PT",4);ll3.add("IT",5);ll3.add("PT",9);ll3.add("IT",2);ll3.add("PT",6);
    ll4.add("KT",5);ll4.add("IT",5);ll4.add("PT",6);ll4.add("PT",11);
    ll5.add("KT",1);ll5.add("KT",6);ll5.add("PT",1);ll5.add("PT",4);
    ll6.add("PT",5);ll6.add("KT",1);ll6.add("IT",4);ll6.add("PT",9);ll6.add("CCT",1);ll6.add("PT",2);ll6.add("IT",6);ll6.add("PT",9);ll6.add("CCT",2);ll6.add("PT",6);
    ll7.add("KT",7);ll7.add("PT",12);ll7.add("IT",1);ll7.add("PT",1);ll7.add("IT",4);ll7.add("PT",2);ll7.add("IT",6);ll7.add("PT",4);ll7.add("PT",6);ll7.add("PT",11);
    fill_symbol_all(ll1);
    fill_symbol_all(ll2);
    fill_symbol_all(ll3);
    fill_symbol_all(ll4);
    fill_symbol_all(ll5);
    fill_symbol_all(ll6);
    fill_symbol_all(ll7);
    cout<<(searcht[find_searcht("main")].symn->pf->fpm == NULL);
    //cout<<searcht[find_searcht("max")].symn->next->next->next->next->next->next->next->name<<endl;

}

//此函数为金汉文与王泰博共同填写
void fill_symbol_all(plotlist &ll)
{
    string ss;    //存储类型
    symbol_node *q;
    plotnode *p;
    p = ll.head->next;
    for(;p != NULL;p = p->next)
    {
        change_level_cnt(p);    //变更大括号深度,及是否在函数内部
        if(p->name == "KT" && KT[p->num - 1] != "return")
        {
            if(p->next->name == "KT" && KT[p->next->num - 1] == "main") //main函数
            {
                current_vallt = new valltable(level_cnt + 1);  //开始main函数活动记录
                q = new symbol_node;
                fill_searcht("main",q,current_vallt);   //填充索引表
                q->name = "main";
                q->cat = "f";
                q->next = NULL;
                q->vall_add = -1;
                switch(KT[p->num - 1][0])
                {
                    case 'i':q->typ = tvalt.head->next;break;
                    case 'd':q->typ = tvalt.head->next->next;break;
                    case 'c':q->typ = tvalt.head->next->next->next;break;
                    case 'b':q->typ = tvalt.head->next->next->next->next;break;
                    default :break;//待补充
                }
                p = p->next;    //指针指向main
                symt.top->next = q;
                symt.top = q;
                current_vallt->fill_all_table(p,q);     //填充活动记录,形参表,符号表及函数表
                q = NULL;
                delete q;
            }
            else if(p->next->name == "IT")
            {
                if(p->next->next->name == "PT" &&PT[p->next->next->num - 1] == "(") //普通函数
                {
                    current_vallt = new valltable(level_cnt + 1);  //开始函数活动记录
                    q = new symbol_node;
                    fill_searcht(IT[p->next->num - 1],q,current_vallt);
                    q->name = IT[p->num - 1];
                    q->cat = "f";
                    q->next = NULL;
                    q->vall_add = -1;
                    switch(KT[p->num - 1][0])
                    {
                        case 'i':q->typ = tvalt.head->next;break;
                        case 'd':q->typ = tvalt.head->next->next;break;
                        case 'c':q->typ = tvalt.head->next->next->next;break;
                        case 'b':q->typ = tvalt.head->next->next->next->next;break;
                        default :q->typ = NULL;break;//待补充
                    }
                    p = p->next;    //指针指向函数名
                    symt.top->next = q;
                    symt.top = q;
                    current_vallt->fill_all_table(p,q);
                    q = NULL;
                    delete q;
                }
                else if(p->next->next->name == "PT" &&PT[p->next->next->num - 1] == "[")//数组
                {
                    ss = KT[p->num-1];
                    fill_AINFL(ss,p);
                }
                else        //普通变量
                {
                     q = new symbol_node;
                     q->name = IT[p->next->num-1];
                     q->cat = "v";
                     q->pf = NULL;
                     q->next =  NULL;
                     switch(KT[p->num - 1][0])
                    {
                        case 'i':q->typ= tvalt.head->next;break;
                        case 'd':q->typ = tvalt.head->next->next;break;
                        case 'c':q->typ = tvalt.head->next->next->next;break;
                        case 'b':q->typ = tvalt.head->next->next->next->next;break;
                        default :break;//待补充
                    }
                    q->vall_add = isinfun ? get_vall_add_and_fill(q) : -1;
                    symt.top->next=q;
                    symt.top=q;
                    q=NULL;
                    delete q;
                }
            }
        }
        else if(p->name == "PT" && PT[p->num - 1] == ",")   //如果是逗号则表示并列
        {
            plotnode *pp = p;
            for(;pp->name != "KT";pp = pp->prior);
            ss = KT[pp->num - 1];
            if(p->next->name != "IT")cout<<"逗号后未检测到变量"<<endl;
            if(p->next->next->name == "PT" && PT[p->next->next->num - 1] == "[") //数组
            {
                fill_AINFL(ss,p);
            }
            else    //普通变量
            {
                q = new symbol_node;
                q->name = IT[p->next->num-1];
                q->cat = "v";
                q->pf = NULL;
                q->next =  NULL;
                switch(ss[0])
                {
                    case 'i':q->typ= tvalt.head->next;break;
                    case 'd':q->typ = tvalt.head->next->next;break;
                    case 'c':q->typ = tvalt.head->next->next->next;break;
                    case 'b':q->typ = tvalt.head->next->next->next->next;break;
                    default :break;//待补充
                }
                q->vall_add = isinfun ? get_vall_add_and_fill(q) : -1;
                symt.top->next = q;
                symt.top = q;
                q = NULL;
                delete q;
            }

        }
        else if(p->name == "IT" && p->next->name == "PT" && PT[p->next->num - 1] == "(") //正在调用函数
        {
            create_valltable(IT[p->num - 1]);
            for(;!(p->name == "PT" && PT[p->num - 1] == ")");p = p->next);   //调整指针
        }

    }
}


void fill_AINFL(string s,plotnode *&p)
{
    symbol_node *q;
    q = new symbol_node;
    q->next = NULL;
    q->name = IT[p->next->num-1];
    q->cat = "t";
    q->pf = NULL;
    TVAL_node *t = new TVAL_node;
    t->next = NULL;
    t->tp = "a";
    AINFL_node  *a;
    a = new AINFL_node;
    a->next = NULL;
    a->low = 1;
    stringstream ss(CCT[p->next->next->next->num-1]);
    ss>>a->high;
    if(s == "int")a->lenth = 4;
    if(s == "double")a->lenth = 8;
    if(s == "char")a->lenth = 1;
    if(s == "bool")a->lenth = 1;
    //lenth_type[i]=a->lenth*a->high;
    //q->ltp=lenth_type;
    q->typ = t;
    t->aip = a;
    switch(s[0])
    {
        case 'i':a->tap = tvalt.head->next;break;
        case 'd':a->tap = tvalt.head->next->next;break;
        case 'c':a->tap = tvalt.head->next->next->next;break;
        case 'b':a->tap = tvalt.head->next->next->next->next;break;
        default :break;//待补充
    }
    if(isinfun)
        q->vall_add = get_vall_add_and_fill(q);
    else q->vall_add = -1;
    symt.top->next = q;
    symt.top = q;
    q = NULL;
    delete q;
    ainflt.top->next = a;
    ainflt.top = a;
    a=NULL;
    delete a;
    tvalt.top->next = t;
    tvalt.top = t;
    t = NULL;
    delete t;
    for(;!(PT[p->num-1] == "]" && p->name == "PT");p = p->next);
}

